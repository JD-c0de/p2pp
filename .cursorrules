# P2PP Development Rules for AI Code Assistants (Cursor, GitHub Copilot, etc.)

## Project Overview
P2PP is a post-processing tool for Palette 2 printers. Uses Python + PyQt5. Modern workflow with uv package manager.

## Critical Architecture Rules

### NEVER Use Universal2 Builds
- PyQt5/QtWebEngine breaks with universal2
- Always build separate Intel (x86_64) and ARM (arm64) for macOS
- Error: "mach-o file, but is an incompatible architecture"

### Architecture Commands
```bash
python3 scripts/check_architecture.py  # Check system architecture
python3 scripts/dev.py test-unit       # Run unit tests
python3 scripts/dev.py format          # Fix formatting
python3 scripts/dev.py all             # Run everything
```

## Development Workflow

### Setup
```bash
uv venv
source .venv/bin/activate
uv sync --extra dev --no-build
```

### Commands
```bash
python3 scripts/dev.py <command>
# test-unit, test-e2e, format, check-arch, all
```

## Code Standards

### Comment Policy
**RULE: No "what" comments, only "why" comments**

Bad:
```python
# Create a virtual environment
uv venv

# Install dependencies  
uv sync
```

Good:
```python
uv venv  # Isolated environment prevents system conflicts
uv sync --no-build  # Skip building to avoid cx_Freeze compatibility issues
```

### DRY Principle
- Extract common patterns into functions
- Use constants for repeated values
- Consolidate similar logic

### Testing Standards
- All tests must actually run and pass
- Use descriptive test names that explain intent
- Test real functionality, not implementation details

## Tool-Specific Rules

### For Cursor Users
- Use `python3 scripts/dev.py` commands for consistency
- Follow existing patterns in pyproject.toml
- Check README.md for project standards

### For GitHub Copilot Users
- Check pyproject.toml for available commands
- Follow existing code patterns in the project
- Use type hints and docstrings for better suggestions
- Reference existing tests in tests/ for patterns

### For All AI Assistants
- Always test generated code before suggesting
- Prefer built-in Python modules over external dependencies
- Follow the simplified architecture (platform module vs custom detection)
- Use uv commands in development, setup.py for building

## File Organization

### Essential Files
- `scripts/check_architecture.py` - Architecture detection (simplified)
- `scripts/dev.py` - Development commands (DRY)
- `pyproject.toml` - Tool configuration only
- `setup.py` - Building only
- `tests/unit/` - Unit tests (18 tests)
- `tests/e2e/` - End-to-end tests
- `.github/workflows/` - CI/CD

### Python Version
- Development: Python 3.9+
- Building: Python 3.11 (cx_Freeze compatibility)

## Quick Reference

### Essential Commands
```bash
python3 scripts/check_architecture.py  # Check what build to download
python3 scripts/dev.py test-unit       # Run 18 unit tests
python3 scripts/dev.py all             # Full verification
```

### Architecture-Specific Builds
```bash
# macOS Intel
export ARCHFLAGS="-arch x86_64"
python setup.py py2app --arch=x86_64

# macOS ARM
export ARCHFLAGS="-arch arm64"
python setup.py py2app --arch=arm64

# Windows/Linux
python setup.py bdist_msi
python setup.py bdist_rpm
```

## Code Style Rules

### Communication Style
- Be terse and direct
- Avoid emojis in code, comments, docs
- Use clear, concise descriptions
- Focus on technical accuracy over enthusiasm

### Python Style
- Use black formatter (88 char line length)
- Import sorting with isort (black profile)
- Type hints required for new code
- pytest for all tests

### File Organization
```
tests/unit/              # Fast unit tests
tests/integration/       # System integration tests  
tests/e2e/              # End-to-end architecture tests
scripts/                # Development utilities
```

## Testing Strategy

### Test Categories (use markers)
- `@pytest.mark.unit` - Fast, isolated tests
- `@pytest.mark.integration` - System component tests
- `@pytest.mark.e2e` - Full workflow tests
- `@pytest.mark.gui` - GUI tests (skip in CI)
- `@pytest.mark.macos/.windows/.linux` - Platform-specific
- `@pytest.mark.intel/.arm` - Architecture-specific

### Test Commands
```bash
uv run test-unit         # Development testing
uv run test-coverage     # Coverage reports
uv run test-arch         # Architecture validation
```

## Architecture Testing

### macOS Builds
- Intel: `--arch=x86_64` + `ARCHFLAGS="-arch x86_64"`
- ARM: `--arch=arm64` + `ARCHFLAGS="-arch arm64"`
- Never: `--arch=universal2`

### Cross-compilation Support
- ARM Macs can build Intel binaries
- Intel Macs can build ARM binaries (Rosetta)
- Test both architectures in CI

## Dependencies

### Core Dependencies
- PyQt5 >= 5.15.0 (GUI framework)
- PyQtWebEngine >= 5.15.0 (web components)
- requests >= 2.31.0 (HTTP)
- packaging >= 23.2 (version handling)

### Development Tools
- pytest (testing framework)
- black (code formatter)
- isort (import sorter)
- flake8 (linting)
- mypy (type checking)
- uv (package manager)

## Common Patterns

### Adding New Tests
1. Choose appropriate test category (unit/integration/e2e)
2. Use fixtures from `tests/conftest.py`
3. Add platform/architecture markers if needed
4. Follow naming: `test_<functionality>_<condition>`

### Adding uv Scripts
1. Add to `[tool.uv.scripts]` in `pyproject.toml`
2. Use descriptive names
3. Chain commands with arrays for multi-step operations
4. Test on all platforms

### Build System Changes
1. Update `setup.py` for build logic
2. Update GitHub Actions workflows
3. Test architecture-specific builds
4. Update documentation

## Platform-Specific Notes

### macOS
- Use py2app for app bundles
- Create DMG files with create-dmg
- Sign with codesign (development: ad-hoc)

### Windows  
- Use setuptools for MSI packages
- Sign with signtool (development: self-signed)

### Linux
- Build RPM and DEB packages
- Use system PyQt5 packages when possible
- Support both x86_64 and ARM64

## AI Assistant Guidelines

### For Cursor Users
- Use project context for architecture awareness
- Reference `.cursorrules` for project standards
- Suggest uv commands over manual steps

### For GitHub Copilot Users
- Check `pyproject.toml` for available uv scripts
- Follow existing code patterns in the project
- Use type hints and docstrings for better suggestions

### Code Generation
- Always include type hints for new functions
- Use pytest fixtures for test setup
- Follow existing import organization
- Add appropriate test markers

### Documentation
- Update relevant docs when changing APIs
- Keep examples current with uv commands
- Test documentation code examples

## Quick Reference

### Essential Commands
```bash
python3 scripts/check_architecture.py  # Check what build to download
python3 scripts/dev.py test-unit       # Run 18 unit tests
python3 scripts/dev.py all             # Full verification
```

### File Locations
- Main config: `pyproject.toml`
- Test config: `tests/conftest.py`
- CI config: `.github/workflows/`
- Build config: `setup.py`

### Architecture Files
- Check script: `scripts/check_architecture.py`
- Test script: `scripts/test_architecture_builds.py`
- Documentation: `docs/ARCHITECTURE_BUILDS.md`